module FastlaneCI
  # Represents a build, part of a project, usually many builds per project
  # One build is identified using the `build.project.id` + `build.number`
  class Build
    # Note, BUILD_STATUSES determine how a build is persisted and how the information is pushed to remote.
    # Example: on success/failure/pending, we automatically update status local + remote
    # With missing_fastfile, we ultimately set a `:failure` when we send a status update to github
    BUILD_STATUSES = [
      :success,
      :pending,
      :missing_fastfile,
      :failure,
      :ci_problem
    ]

    # A reference to the project this build is associated with
    attr_reader :project

    # @return [Integer]
    attr_reader :number

    # @return [String]
    attr_reader :status

    # @return [DateTime] Start time
    attr_reader :timestamp

    # @return [Integer]
    attr_accessor :duration

    # @return [String] The git sha of the commit this build was run for
    attr_reader :sha

    # @return [Array(Artifact)] The artifacts generated by the build.
    attr_accessor :artifacts

    # @return [String] An optional message to go along with the build, will show up as part of the build status on
    # github
    attr_accessor :description

    # @return [String] the trigger type that triggered this particular build
    attr_accessor :trigger

    def initialize(
      project: nil,
      number: nil,
      status: nil,
      timestamp: nil,
      duration: nil,
      sha: nil,
      description: nil,
      trigger: nil
    )
      @project = project
      @number = number
      @status = status
      @timestamp = timestamp
      @duration = duration
      @sha = sha
      @artifacts = []
      @description = description
      self.trigger = trigger
    end

    # Most cases we don't want people doing this, but there are a couple valid reasons, make it explicit
    def update_project!(new_project)
      @project = new_project
    end

    def status=(new_value)
      return if new_value.nil? # as during init we might init with 0 when filling in JSON values
      new_value = new_value.to_sym
      raise "Invalid build status '#{new_value}'" unless BUILD_STATUSES.include?(new_value)
      @status = new_value
    end

    def link_to_remote_commit
      project.repo_config.link_to_remote_commit(sha)
    end
  end
end
